# AOP

## 프록시 패턴

* **클라이언트 -> 부가기능 -> 핵심기능** 과 같은 구조에서 사용자가 부가기능이 핵심기능이라고 생각하고 사용하지만, 부가기능을 통해 핵심기능을 실행시키는 형태를 말한다.
* 부가기능 부분을 프록시, 핵심기능 부분을 타겟이라고 한다.
* 타겟과 프록시는 같은 인터페이스를 구현했으며, 프록시가 타깃을 제어할 수 있는 위치에 존재한다.
* 프록시 패턴의 사용 목적
    1. 클라이언트가 타깃에 접근하는 방법을 제어하기 위해
    2. 타겟에 부가적인 기능을 부여해주기 위해
* 프록시라는 용어와 디자인 패턴에서 말하는 프록시 패턴은 다르다.
    * 프록시 : 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝트를 두는 방법을 총칭
    * 프록시 패턴 : 프록시를 사용하는 방법 중에서 타겟에 대한 접근 방법을 제어하려는 목적을 가진 경우

## 데코레이터 패턴

* 부가적인 기능을 런타임 시 다이나믹하게 부여해주기 위해 프록시를 사용하는 패턴
* 즉, 컴파일 시점에서 프록시와 타겟의 연결이 정해져 있지 않다.
* 데코레이터 패턴의 프록시는 한개로 제한되어 있지 않다.
* 프록시가 타겟을 사용하도록 고정시킬 필요가 없다.
* 타겟의 코드를 손대지 않으며 클라이언트가 호출하는 방법도 변경하지 않고 새로운 기능을 추가할 때 유용하다.

### 다이나믹 프록시의 장/단점

> 장점
> 1. 프록시 팩토리 빈의 재사용성
>     * 코드 수정없이 다양한 클래스에 적용할 수 있다.
>     * 타깃 오브젝트에 맞는 프로퍼티 정보를 설정해서 빈으로 등록하기만 하면 된다.
> 2. 타깃 인터페이스를 구현하는 클래스를 모두 만드는 번거로움이 없다.
>     * 하나의 핸들러 메소드를 구현해서 수많은 메소드에 부가기능을 부여해줄 수 있다.
> 3. 다이나믹 프록시 팩토리 빈을 DI를 하면 다이나믹 프록시 생성 코드도 제거할 수 있다.

> 한계
> 1. 프록시를 통해 타깃에 부가기능을 제공하는 것은 메소드 단위로만 일어나는 일이다.
>    * 여러개의 클래스에 공통적인 부가기능을 제공하는 일은 다른 방법을 사용해야 한다.
> 2. 하나의 타겟에 여러개의 부가기능을 적용하는데 문제가 있다.
>    * 부가기능 하나당 추가 코드와 XML 설정이 생기고, 적용해야 하는 메소드가 많아지면 그 수만큼 많아지고 설정이 복잡해지게 된다.
> 3. TransactionHandler 오브젝트가 프록시 팩토리 빈 개수만큼 만들어진다.
