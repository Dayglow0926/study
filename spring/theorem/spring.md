# Spring

## 제어의 역전(Inversion of Control)

* 프로그램의 제어 흐름 구조가 뒤바뀌는 것
* 일반적인 프로그램은 main과 같은 시작에서 다음에 사용될 오브젝트와 메소드를 결정하고, 그 오브젝트가 다음 오브젝트와 메소드를 호출하는 작업이 반복
* 각각의 오브젝트는 프로그램 흐름을 결정하거나 사용할 오브젝트를 구성하는 작업에 능동적으로 참여한다
* 즉, 모든 종류의 작업을 사용하는 쪽에서 제어하는 구조이다
* 이러한 지금까지 일반적으로 구현하던 것들을 반대로 실행
* 제어의 역전에서 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지도, 생성하지도 않는다
* 또한, 자신이 어떻게 만들어지고 어디서 사용되는지를 알 수 없다
* main과 같은 엔트리 포인트를 제외한 모든 오브젝트는 위임받은 제어 권한을 갖는 특별한 오브젝트에 의해 결정되고 만들어진다

## 의존관계 주입(Dependency Injection)

* A -> B의 관계로 의존 할 때
    * B가 변하면 A에 영향이 있다
    * 하지만 B는 A에 의해 영향을 받지 않는다.
* 오브젝트가 만들어지고 런타임 시에 의존관계를 맺는 대상, 실제 사용대상인 오브젝트를 의존 오브젝트라고 한다
* 의존관계 주입은 구체적인 의존 오브젝트와 그것을 사용할 주체(보통은 클라이언트) 오즈젝트를 런타임 시에 연결해주는 작업을 말한다
* 의존관계 주입은 다음의 세가지 조건을 충족하는 작업을 말한다
    1. 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 즉, 인터페이스에만 의존하고 있어야 한다
    2. 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재(application context, Bean Factory...)가 결정한다
    3. 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 주입해줌으로써 만들어진다
* DI가 되기 위해서는 그 오브젝트는 컨테이너가 관리하는 빈이어야만 한다
* 스프링에서 DI를 사용하는 방법
    1. 생성자를 이용한 방법
    2. setter를 이용한 방법
    3. method를 이용한 방법

## Bean

* Spring이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트
* 자바빈 또는 엔터프라이즈 자바빈(EJB)에서의 빈과 비슷한 오브젝트 단위의 애플리케이션 컴포넌트
* 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트
* 스프링에서 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 Bean Factory라고 함
    * 보통 Bean Factory 보다 좀더 확장한 application context를 주로 사용
    * application context는 IoC 방식을 따라 만들어진 일종의 Bean Facotry
* ApplicationContext는 BeanFactory 인터페이스를 상속하여 구현됨
* Spring Bean을 이용하여 IoC 기능을 이용할 경우
    1. 클라이언트는 구체적인 팩토리 클래스를 알 필요 없다
    2. 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공한다
    3. 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다

## configuration metadata

* 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보를 의미
* 컨테이너에 어떤 기능을 세팅하거나 조정하는 경우에도 사용함
* 하지만, 대부분 IoC 컨테이너에 의해 관리되는 애플리케이션 오브젝트를 생성하고 구성할 때 사용

## 싱글톤 레지스토리

* 스태틱 메소드와 private 생성자를 사용해야 하는 싱글톤이 아닌 평범한 자바 클래스를 싱글톤으로 활용할 수 있게 해준다
* IoC방식의 컨테이너를 사용해서 생성과 관계설정, 사용 등에 대한 제어권을 컨테이너에게 넘기면 손쉽게 싱글톤 방식으로 만들어져 관리 할 수 있다
* 스프링이 지지하는 객체지향적인 설계 방식과 원치, 디자인 패턴등을 적용하는데 아무런 문제를 가지지 않는다
* 싱글톤 방식이기 때문에 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 상태정보를 내부에 갖고 있지 않은 무상태 방식으로 만들어져야 한다
    * 즉, 개별적으로 바뀌는 정보는 로컬 변수로 정의하거나, 파라미터로 주고받으면서 사용하게 해야 한다

## 단일 책임 원치

* 하나의 모듈은 한 가지 책임을 가져야 한다.
* 하나의 모듈이 바뀌는 이유는 한 가지여야 한다.
* 스프링에서 단일 책임 원칙을 잘 적용하기 위해서는 인터페이스를 도입하고 이를 DI를 통해 연결해야 한다.
* 어떠한 변경이 필요할 때, 수정 대상이 명확해진다.