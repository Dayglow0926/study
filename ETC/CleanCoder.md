# The Clean Coder - Robert C. Martin (밥 아저씨)

##  들어가며

'들어가며' 파트에서 1986.01.28 우주 왕복선 챌린저 폭발사고에 대한 내용이 있다. 기술자들은 O링의 문제점을 알고있고, 발사를 중지해야 한다고 강력히 주장했지만 관리자는 재정적, 정치적 압박에 굴복해 발사를 진행하였다. 그로인해 7명의 용감한 우주비행사가 사망하는 사고가 발생하였다. 이는 분명 관리자들은 잘못을 했고, 범죄자이다. 여기까지는 당연한 추론이고 생각이 들것이다. 그리고 문제가 있었다고 말한 기술자는 문제가 있었다고 강력히 말했기에 큰 잘못은 없다라고 생각하며 읽었다. 마지막 단란에서 '하지만 가끔 궁금해지곤 한다. 그 기술자들 중 한밤중에 잠에서 깨어나, 크리스타 매콜리프 어머니의 표정을 잊지 못해, 탐사 전문 기자 댄 래더 같은 사람이라도 불렀으면 어땠을까라고 생각하는 사람이 한 명이라도 있을까?' 라는 글을 보고 1차원적이고 직관적인 문제에 대한 추론은 쉽게 했지만, 그 이외의 것들이나 요소, 맞다고 생각된 부분에서의 존재할 수 있는 오류 등 당연하다고 생각되던 것들을 다시 상기시켜주는 파트였다.

##  미리 읽어두기

* 이 책에서의 프로 프로그래머란 태도, 원칙, 행동이 프로의 핵심이라 생각한다
* ~~60 ~ 70년대 프로그래밍 (천공, 어셈블러, 코볼, 포트란, BAL, PDP-8 ...)에 대한 이야기가 있는데, 솔찍히 잘..ㅎ~~
* 작가는 이 책을 통해 지금까지 프로그래밍을 하며 자신의 범죄의 사건일지, 초년생 때 했던 실수를 피할 수 있도록 만들어주는 안내서라고 말한다

##  1장 - 프로의 마음가짐

* 함부로 바라지 마라
  * 프로페셔널리즘에는 명예와 긍지, 동시에 책임과 의무를 나태낸다
  * 프로가 아니라면 하는 일에 책임을 느낄 필요가 없으며 회사에 고스란히 책임을 떠넘겨도 된다
  * 프로는 실수하면 스스로 뒷감당을 해야 한다
  * 결국, 프로페셔널리즘은 책임이 전부!

* 책임감을 가져라
  * 책에서 79년 전화선 감시 시스템 소프트웨어 '담당 책임자'로 일할 때 일화를 말해준다
  * 그 당시 야간 작업을 테스트하지 않고 선적한 무책임한 짓을 하였다 한다
  * 테스트를 소흘히 한 이유는 제때 선적했다고 떠벌리고 싶은 내 체면을 세우는 일을 위한 것이었다
  * 테스트를 하지 못해서 제때 선적할 수 없다고 말했다면 고객은 화를 냈을지 몰라도 고객은 데이터를 잃어버리지 않았을 테고, 서비스 매니저들도 전화하지 않았을 것이다

* 무엇보다도 해를 끼치지 마라
  * 책임감을 말할 때 히포크라테스 선서가 있을 것이다
  * 소프트웨어 관점에서의 해는 기능과 구조 양쪽에 해를 끼치게 된다

* 기능에 해를 끼치지 마라
  * 소프트웨어는 너무 복잡해서 오류가 생길 수밖에 없다
  * 하지만 너무 복잡하다는 이유로 책임이 사라지진 않는다
  * 즉, 완벽하지 않다는 사실에 책임을 져야 한다
  * 완벽한 소프트웨어를 만드는 일 자체가 불가능하지만 완벽하지 않아도 괜찮다는 뜻이 아닌 것이다
  * 프로라면 한 명도 빠짐없이 오류에 책임을 져야하고, 오류가 명백하지 않더라도 상황이 어떻게 돌아가는지 밝혀야 한다
  * 프로가 되겠다는 포부를 가지고 있다면 사과하는 법을 익혀야 한다
  * 또한, 같은 오류를 반복하면 안 된다

* QA는 아무것도 찾지 못해야 한다
  * 소프트웨어를 출시할 때는 QA가 문제를 찾지 못할 것이라고 어느 정도 자신할 수 있어야 한다
  * 코드에 결함이 있는 걸 알면서도 QA에게 코드를 보내는 일은 매우 프로답지 못한 행동이다
  * 결함이 있는 코드란, 확신을 갖지 못하는 코드는 모두 결함이 있는 코드이다
  * QA를 오류를 찾는 용도로 사용하는 곳이 많고, 오류를 많이 찾는 순으로 QA에게 보상을 주는 회사도 존재한다
  * 이러한 행동은 일정을 망치고 개발팀의 모험심을 뿌리부터 갉아먹으며 게으르고 무책임할 뿐이다
  * 잘 돌아가는지 아닌지도 모르는 코드를 QA에게 보내는 개발자는 '해를 끼치지 마라' 라는 규칙을 어기는 프로가 아니다
  * **QA는 오류를 대부분 찾으니, 사과할 준비를 하고 오류가 어떻게 감시망을 뚫었는지 알아내 다시는 그런 일이 생기지 않도록 방비해야 한다**
  * **QA나 사용자가 문제를 찾을 때마다, 개발자는 놀라움과 분함을 느끼는 것이 마땅하며 다시는 그런 일이 생기지 않도록 마음을 다져야 한다**

* 제대로 작동하는지 아닌지 알아야 한다
  * 테스트하고, 또 테스트 해라
  * 월화수목금토일, 일곱가지 방식으로 테스트해라
    * 이렇게 하면 테스트 시간이 너무 많이 걸릴테고, 마감일을 지키지 못할 수 있다
    * 즉, 테스트를 자동화해야 한다
    * 이는 순식간에 실행할 수 있는 테스트를 만들고 가능한 자주 돌려라
    * **모.조.리**
  * 100% 테스트 커버리지를 권장이 아닌 강력히 요구한다
  * 어떤 코드는 테스트하기 어려울 수 있지만, 이는 테스트하기 어렵게 설계했기 때문이다
  * 가장 좋은 방법은 테스트 코드를 먼저 작성한 다음, 그 테스트를 통과하도록 코드를 작성하는 것이다
    * **이것이 테스트 주도 개발인 TDD의 원칙이다**

* 자동화된 QA
  * 어떤 시스템은 너무 중요해서 자동화된 테스트를 잠깐 돌려보는 것만으로는 출시 준비가 됐다고 하기는 부족하다
  * 반면 개발자 입장에서는 작성한 코드가 잘 돌아가고, 시스템의 다른 부분에 악영향을 주지 않았는지 알아내는, 비교적 빠르고 믿을 만한 메커니즘이 필요하다
  * 그래서 테스트를 자동화하면 최소한 시스템이 QA를 통과할 정도는 된다고 말할 수 있다

* 구조에 해를 끼치지 마라
  * 전체 구조를 희생하면서까지 기능을 추가하는 일은 헛수고다
  * 구조가 좋아야 코드가 유연해진다
  * **소프트웨어는 변한다라는 생각은 모든 소프트웨어 프로젝트의 기본 가정이다**
  * 즉, 변경을 할 때 터무니없는 비용을 치르지 않고 변경할 수 있어야 한다
  * 유연하면서 유지하기 쉬운 구조로 소프트웨어를 설계하는 데 필요한 원칙과 패턴을 소개한 [글](https://book.naver.com/bookdb/book_detail.nhn?bid=144677)도 있다
  * 간단한 요령이 있다
    * 소프트웨어가 바꾸기 쉬운지 아닌지 증명하는 유일한 길은 실제로 조금 바꿔보는 것이다
    * 코드를 조금 바꾸는 일은 항상 해야 한다
    * 이러한 것을 보이스카웃 규칙이라 하고, 모듈을 체크인할 때는 항상 체크아웃했을 때보다 깨끗해야 한다는 규칙이다
    * 일반적으로 동작 중인 소프트웨어를 계속 바꾸는 일은 위험하다고 생각하지만, 정말 위험한 일은 소프트웨어를 고정된 상태로 두는 일이다
    * 일반적으로 코드 바꾸기를 무서워하는 이유는 코드를 망가트릴까봐인데, 이는 테스트가 없기 때문이다
    * **결국엔 테스트이다**

* 직업 윤리
  * 자신의 경력은 자신이 책임져야 한다
  * 훈련, 컨퍼런스, 책 등 이러한 것은 회사 책임이 아니며 스스로 책임져야 한다
  * 회사에서 이러한 호의를 베푸는 것을 당연시 하면 안 된다
  * 자신에게 경력을 위해 투자하는 시간을 가져라

* 전산 분야 지식을 익혀라
  * [나씨-슈나이더만](https://en.wikipedia.org/wiki/Nassi%E2%80%93Shneiderman_diagram), [밀리 상태 기계, 무어 상태 기계의 차이](http://egloos.zum.com/dangling/v/481382), [퀵 소트](https://ko.wikipedia.org/wiki/%ED%80%B5_%EC%A0%95%EB%A0%AC)를 검색 없이 작성 할 수 있는가, [변환 분석](http://terms.tta.or.kr/dictionary/dictionaryView.do?subject=%EB%B3%80%ED%99%98+%EB%B6%84%EC%84%9D) 등등을 알고 있는가?
  * 50년간 전산 분야에는 아이디어, 규율, 기법, 도구, 전문 용어가 넘쳐 흘렀으며 프로가 되고 싶다면 지식을 익혀 큼지막한 덩어리를 만든 다음 그 정어리를 계속 키워야 한다
  * 옛날에 비해 지금은 24시간 꼬박 기다리며 컴파일 하지 않고, 시스템 크기는 몇 기가 바이트나 되고, 지구 전체에 퍼진 네트워크는 실시간으로 정보를 제공한다
  * 하지만, 50년 전에 쓰던 if, while 문장은 그대로 사용한다
  * 지난 50년간 쓸모없게 된 아이디어는 거의 없고, 몇몇 아이디어(예를 들어 폭포수)는 비주류로 물러나긴 했다
  * **프로 소프트웨어 개발자라면 알아야 하는 최소한의 기술 목록**
    * 디자인 패턴 - 24가지 GOF 패턴을 설명할 수 있고, POSA 패턴을 실무에 적용할 수준으로 알아야 한다
    * 설계 원칙 - SOLID 객체지향 원칙을 알아야 하고 컴포넌트 개념을 충분히 이해해야 한다
    * 방법론 - XP, 스커럼, 린, 칸반, 폭포수, 구조적 분석, 구조적 설계 개념을 충분히 이해햐야 한다
    * 원칙 - 테스트 주도 개발(TDD), 객체지향 설계, 구조적 프로그래밍, 지속적 통합, 짝 프로그래밍을 실천해야 한다
    * 도구 - UML, 데이터 흐름도, 구조 차트, 페트리 넷, 상태전이 다이어그램과 테이블, 흐름도, 결정 테이블을 어떻게 쓰는지 알아야 한다

* 끊임없이 배우기
  * IT 산업은 미친듯이 바뀐다!
  * 책, 기사, 블로그, 트윗, 컨퍼런스, 여러 모임, 스터디 그룹에 들어가라
  * 익숙한 영역을 벗어나 낯선 것을 익혀라

* 연습
  * 일상적인 업무를 연습이라 부르면 안 된다
  * 연습에 대해서는 6장에서 자세히 나오며, 볼링 점수 계산이나 인수분해 프로그래밍 같은 간단한 훈련을 계속해서 반복하는 등과 같은 방법이 있다
  * 이러한 훈련을 품새라 한다
  * 품새는 대개 프로그래밍으로 간단한 문제를 푸는 형식이다
    * 품새의 핵심은 손가락과 두뇌를 단련시키는 일이다

* 함께 일하기
  * 배움에 도움이 되는 두 번째 방법은 다른 사람들과 함께 일하는 것이다
  * 함께 프로그래밍하고, 함께 연습하고, 함께 설계하고 계획하라
  * 그렇다고 100%를 다른 사람과 하라는 의미는 아니다

* 멘토링
  * 배우기에 가장 좋은 방법은 가르치는 것이다
  * 쓸모 있는 내용을 머릿속에 가장 빠르고 강하게 넣는 방법은 자신이 책임지고 담당하는 사람들과 이야기를 주고 받는 일이다
  * 새로운 사람을 조직에 익숙하게 만드는 가장 좋은 방법은 옆에 앉아서 몇 가지 작업 요령을 알려주는 일이다

* 업무 지식을 익혀라
  * 프로 소프트웨어 개발자는 자신이 프로그래밍하는 제품의 업무 분야 지식을 알아야 한다
  * 전문가가 될 필요까진 없지만 적절한 수준에 도달하기 위해 어느 정도 노력을 기울여야 한다
  * 새로운 분야에서 프로젝트를 시작하게 되면, 관련 분야의 책을 한두 권 읽어 보고, 고객이나 사용자들과 면담 시간을 잡아 업무 기초에 대해 이야기를 나눠보고, 업무 전문가들과 함께 시간을 보내고, 전문가들의 원칙과 가치를 이해해 보자
  * 제품 사양이 사업 진행에 이치가 맞는지 따져보지 않고 그저 사양에 따라 코딩하는 일은 최악이다

* 회사와 고객에 동질감을 가져라
  * 회사의 문제가 자신의 문제다
  * 문제가 무엇인지 이해하고 최선의 해결책을 만들기 위해 일해야 한다
  * 제품을 개발할 때는 회사의 입장에서 개발 중인 기능이 회사의 요구사항을 만족하는지 확인해야 한다

* 겸손
  * 프로그래밍은 무에서 유로 만드는 창조의 행위이다
  * 혼돈에 질서를 부여하고, 자칫하면 어마어마한 피해를 입힐지도 모르는 위험을 무릅쓰고 기계를 정밀하게 움직이도록 명령하므로 프로그래밍은 극도로 오만한 행위이다
  * 프로는 자신의 일을 이해하고 그 일에 자부심을 가지고 자기 능력을 확신하고, 확신을 바탕으로 계산한 위험을 짊어진다
  * 그러나 프로는 때때로 실패한다는 사실과 위험 계산이 틀릴지도 모른다는 것과 언젠가 자신의 능력이 부족해지는 날이 온다는 사실을 안다
  * 목표가 무너질지도 모른다는 사실을 알고있으며, 목표가 무너졌다면 하워드의 충고처럼 "그냥 웃어. 이 친구야"를 생각하자

##  아니라고 말하기

프로라면 권위에 맞서 진실을 말해야 한다

프로는 관리자에게 아니라고 말하는 용기를 가져야 한다

* 반대하는 역할
  * 어려운 결정을 내리는 최고의 방법은 대립하는 사람들 사이의 충돌이다
  * 협상
    * 프로그래머가 거짓말을 하는경우, 관리자는 문제를 명확히 하지 않은 경우
    * 프로그래머가 단정적으로 말하지 않은 경우, 관리자는 자신의 목적이 달성되든 말든 싱경쓰지 않는 경우
    * 위의 경우는 각자에게 무책임하고 상대에게도 무책임하다
    * '아니'라고 말하며 상호 합의하에 해결책을 만드는게 가장 현명한 방법이다
    * 이를 위해서는 목표를 완벽히 정의하고 적극적으로 먹적 달성을 위해 노력하는 과정이 필요하다

* 왜 그런지가 중요한가?
  * '아니'라고 말했을 때, 왜 그런지를 설명한다면 상황을 파악하고 현실을 받아들이는데 도움이 될지도 모른다
  * 하지만, 세부사항을 과하게 알려주는 일은 밀착 관리를 초래한다

* 이해관계가 높을 때
  * 이해관계가 높을 때야 말로 아니라고 말할 가장 중요한 순간이다
  * 이익과 손해가 클수록 아니라는 말의 가치도 높아진다

* 팀 플레이어
  * 팀 플레이어가 된다는 의미는 맡은 위치에서 최선을 다하고, 동료의 일이 잘 안 풀릴 때 도와준다는 뜻이다
  * 팀 플레이어는 의사소통을 자주하고, 동료들을 살피고, 최선을 다 해 맡은 바 책임을 완수한다
  * 팀 플레이어는 항상 "네"라고 하지 않는다

* 노력해보기
  * '노력 **해볼게요**'란 말은 없다
  * 노력이란 '추가로 힘을 쏟는다'라는 말이고, 이 말은 이전에는 최선을 다하지 않았다는 뜻이된다
  * '노력'해도 원하는 결과를 만들지 못하면 실패다
  * 비축해 둔 에너지도 없고, 새 계획도 없고, 행동을 바꿀 생각도 없고, 이성적으로 봤을 때 원래 예측에 확신이 든다면, 노력하겠다는 약속은 근본적으로 정직하지 못한 행동이며 거짓말이고 이때 '노력하겠다'라는 말은 체면을 차리고 대립을 피하려 했음이다

* 수동적 공격성, 두고 보자는 심보
  * 어떠한 문제에 대해 자신은 방어할 수 있는 자료와 서류의 복사본을 챙겨서 끔찍한 결과가 발생했을 때, 자신은 문제가 없었다고 준비하는 것을 수동적 공격이라 한다
  * 이러한 끔찍한 결과가 발생하기 전에 알고 있다면 말을 해서 상황을 좋게 만드는 것이 팀 플레이다

* 예라고 말하는 비용
  * 우리는 언제나 예라고 말하고 싶고, 건강한 팀은 예라고 할 수 있는 방법을 찾으려 애쓴다
  * 잘 돌아가는 팀의 관리자와 개발자들은 서로 만족할 수 있는 계획이 나올 때까지 협상한다
  * 가끔은 올바른 예를 말할 방법이 두려움 없이 아니라고 말하는 수밖에 없을 때도 있다
