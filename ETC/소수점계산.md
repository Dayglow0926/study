# 부동 소수점 - Float!

* 부동 소수점 방식은 실수를 컴퓨터 상에서 근사하여 표현할 때 소수점의 위치를 고정하지 않고 그 위치를 나타내는 수를 따로 적는 것
* 유효숫자를 나타내는 가수와 소수점의 위치를 풀이하는 지수로 나누어 표현
* 고정 소수점 방식보다 넓은 범위의 수를 나타낼 수 있어 과학기술 계산에 많이 이용되지만, 근삿값으로 표현됨
* 부동 소수점 방식은 고정 소수점 방식보다 연산 속도가 느림
* 고정 수소점과 달리 소수 부분의 자릿수가 일정하지 않으나, 유효 숫자의 자릿수는 정해져 있다
* 8.875를 표현하면 1.000111 * 2^3 으로 표현하며, 1000.111을 정규화 한 것이다

--------------------------------------------------------------------------------
# 고정 / 부동 소수점

* 고정 소수점
  * 정수를 표현하는 비트 수와 소수를 표현하는 비트 수를 미리 정해놓고 해당 비트 만큼만 사용해서 숫자를 표현하는 방식
  * 정수를 표현하는 bit를 늘리면 큰 숫자를 표현가능 -> 정밀한 숫자를 표현하기 힘들어짐
  * 소수를 표현하는 bit를 늘리면 정밀한 숫자 표현가능 -> 큰 숫자를 포현하기 힘들어짐

* 부동 소수점
  * 소수점을 고정하지 않고 실수를 표현
  * IEEE의 표준제안 방식

![IEEE754](./images/IEEE754.png)

  * sign 1 Bit / exponent 8 Bit / fraction 23 Bit
  * (-1)^signBit(1 + fraction) * 2^(exponent - bias(127))
  * IEEE754 표현 방식에서는 127 + 지수를 기록
    * 127.3을 표현하면 127 : 1111111 -> 1.111111 * 2^6
    * 0.3 : 0.01001100110011001...
    * 즉, 1.11111101001100110011001... * 2^6
    * sign : 0(양수) / exponent : 10000101 (127 + 6) / 11111101001100110011001
    * '0.01001100110011001' 이 표현도 정확히 0.3을 표현된 것이 아니고 0011이 반복해서 나타난다
    * 소수점이 '정확한 값'이 아닌 '근사의 값'으로 표현되므로 float끼리 계산을 하면 오차가 발생한다

```Python
floatResult = 0.0

for i in range(0, 100):
  floatResult += 0.1

print(floatResult)
#9.99999999999998
```

--------------------------------------------------------------------------------
# 그러면 곱셈은?

* 두 수의 exponent를 더해준다
* 두 수를 곱한다
* scientific-notation으로 정리하여 exponent를 다시 계산한다
  * scientific-notation이란 표현식을 맞춰주는 것
  * 계산을 한 후, 값이 일의 자리숫자에 1이 오도록 연산을 맞춰주는 것
  * 1을 제외한 fraction 값을 구하기 위해서
* ex) 1.01 * 2^2 와 1.11 * 2^0 (5 * 1.75) 계산
  * exponent를 더해준다 -> 2 + 0 = 2
  * 두 수를 곱한다 -> 1.01 * 1.11 = 10.0011
  * scientific-notation을 적용 -> 10.0011 * 2^2 = 1.00011 * 2^3

--------------------------------------------------------------------------------
# 오차가 많은데?

* IEEE754에서 rounding이라고 하는 처리 방식을 제시한다
  * round to zero, round up, round down, round even, round to nearest 등
  * Java specification에서는 round to nearest 방식을 이용해 round 처리를 한다
  * round to nearest 방식은 가까운 곳으로 rounding 하는 방식
  * 52번째 자리까지 계산한 후, 남는 부분을 Round to nearest 처리
    * Round to nearest 처리란, 값을 버려 0으로 내림하는 것보다 1로 올림하는 것이 52번째 이후의 값에서 따져봤을 때 더 가까운 값이므로 올려준다

* [이 외에 python에서 소수점 오차 해결을 위한 여러가지 방법이 있다](https://winterj.me/Floating-Point/)
* [또는 decimal 라는 128비트 데이터 형식도 있다](https://docs.microsoft.com/ko-kr/dotnet/csharp/language-reference/keywords/decimal)
