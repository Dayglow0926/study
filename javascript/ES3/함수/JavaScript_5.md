# JavaScript 5

어떤 특정 작업을 수행하기 위해 필요한 일련의 구문들을 그룹화한 개념을 함수라 한다

미리 작성된 함수를 재사용 할 수 있다 - 코드의 재사용

함수의 일반적 기능은 특정 작업을 수행하는 구문들의 집합을 정의하고 필요시 호출하여 필요한 값 또는 결과를 얻는 것

이 외에도 객체 생성, 객체의 메소드 지정, 정보의 구성 및 은닉, 클로저, 모듈화 등등 기능을 수행할 수 있다

함수는 구문의 집합으로 모듈화의 근간이 된다 -> 프로그래밍 기술은 요구사항의 집합을 자료구조와 함수의 집합을 변환하는 것이 일반적이다

함수 또한 객체이며 입급객체, First-class object라 한다

함수는 호출할 수 있다는 다른 객체와 다른 특징을 가지고 있으며, 함수도 객체이므로 변수나 객체, 배열 등에 저장할 수 있고 다른 함수로 전달되는 인자와 함수의 반환값이 될 수 있다

##  함수정의
* 함수 선언문
  * function 키워드와 이하의 내용으로 구성
  * 함수명, 매개변수 목록, 함수 몸체
```JavaScript
function 함수명(매개변수 목록...){
  함수 몸체
};

//하지만 이 변수명만 가지고는 외부 코드에서 접근이 불가능하다
//위와 같이 선언된 함수 선언문은 자바 스크립트 엔진에 의해 아래와 같이 변경이 되어 함수 이름으로 코드 외부에서 접근이 가능한 것이다

var 함수명 = function 함수명(매개변수 목록...){
  함수몸체
};
//결국 함수 선언문도 함수 표현식과 동일하게 함수 리터럴 방식으로 정의되는 것이다
```
  * 함수 선언문에서 함수명은 생략 불가능, 자신을 재귀적 호출하거나 자바스크립트 디버거가 해당 함수를 구분할 수 있는 식별자
  * 매개변수 목록은 0개 이상의 목록으로 다른 언어와 다르게 매개변수의 자료형을 기술하지 않는다
  * 함수의 몸체는 실제 함수가 호출되었을 때 실해오디는 구문들의 집합
  * 함수 몸체에서 return을 통해 결과값을 반환할 수도 있다

* 함수 표현식
  * 함수는 일급 객체
  > 무명의 리터럴로 표현이 가능<br>
  변수나 자료구조에 저장할 수 있다<br>
  함수의 바라미터로 전달할 수 있다<br>
  반환값으로 사용할 수 있다<br>

  * 일급 객체라는 것을 이용하여 함수 리터럴 방식으로 함수를 정의하고 변수에 할당
```javascript
var 변수명 = function(매개변수 목록...){
  함수 몸체
}
//이렇게 함수 표현식으로 표현하면 변수명을 생략할 수 있으며, 이러한 함수를 익명 함수라고 한다

var foo = function multiply(a, b){
  return a * b;
};
//가명 함수 표현식
var bar = function(a, b){
  return a * b;
};
//익명 함수 표현식

console.log(multiply(10, 5)); //Uncaught ReferenceError: multiply is not defined

var foobar = bar;
console.log(foobar(10, 5)); //50
//bar와 foobar는 동일한 익명 함수의 참조값을 가진다
```

* Function 생성자 함수
  * 함수 선언문, 표현식 모두 함수 리터럴 방식으로 사용(선언문은 자바스크립트 엔진이 기명 함수 표현식으로 변환하면서)
  * 이러한 두가지 함수 선언의 경우 리터럴 방식으로 함수를 정의하는데 이는 **내장 함수 Function 생성자 함수로 생성하는 것을 단순화시킨 축약법**
  * Function 생성자 함수는 Function.protorype.constructor 프로퍼티로 접근할 수 있다

```javascript
new Function(arg1, arg2, ... argN, functionBody)
//위는 Function 생성자 함수로 함수를 생성하는 문법

var 변수명 = new Function('매개변수1', '매개변수2', ..., '매개변수N', '함수몸체');
//위에 생성한 multiply 함수를 위의 new Function으로 생성하면
var multiply = new Function('num1', 'num2', 'return num1 * num2');
```

##  함수 호이스팅
```javascript
var res = square(5);

function square(number){
  return number * number;
}
//함수 호이스팅
---------------------------------------------------------------
var res2 = square2(5);  // TypeError: square is not a function

var square = function(number){
  return number * number;
}
```
위와 같이 함수 선언문의 경우 함수 선언 위치와 상관없이 함수 호출이 가능하다

**자바스크립트는 EB6의 let, const를 포함하여 모든 선언(var, let, const, function, function*, class)을 호이스팅 한다!!!**

함수 선언무으로 정의된 함수는 자바스크립트 엔진이 스크립트가 로딩되는 시점에 초기화하고 이를 variable object에 저장한다

**함수 선언, 초기화, 할당이 한번에 이루어 진다!** 고로 함수 선언문으로 정의된 함수는 선언 위치에 상관없이 소스 어느곳이든 호출이 가능하다

함수 표현식의 경우 함수 호이스팅이 아니라 변수 호이스팅이 발생, 변수 호이스팅은 변수 생성 및 초기화까지 일어나므로 아직까지 할당이 안됬으므로 'undefined'가 변수에 들어가 있다

즉, 실제값의 할당은 할당문에서 이뤄지는데 아직 함수 내용이 할당이 안됬으므로 함수가 아니라고 나오는 것

**함수 표현식은 함수 선언문과 달리 스크립트 로딩 시점에 VO에 함수를 할당하지 않고 runtime에 해석되고 실행됨**

자바스크립트의 권위자인 더글러스 크락포드는 함수 표현식만을 사용할 것을 권고 -> 함수 호이스팅은 함수를 호출 전 선언한다는 규칙을 무시하므로 코드의 구조를 엉성하게 만들 수 있다고 지적

**함수 선언문으로 함수를 정의하면 대규모 애플리케이션의 경우 인터프리터가 너무 많은 코드를 변수 객체에 저장하므로 애플리케이션의 응답속도는 현저히 떨어질 수 있다**

이렇게 한가지를 더 배웠네!! 평소에 함수 선언문으로 ~~편해서~~ 그리고 습관되서 사용했는데, 함수 표현식으로 바꿔야 겠다
